// Copyright 2012- Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

/**
 * This is the input file to JavaCC for generating a scanner and a parser for j--. From the
 * specification in this file, JavaCC generates, among other files, a JavaCCParser.java program
 * (the parser) and a JavaCCParserTokenManager.java program (the scanner).
 */
PARSER_BEGIN(JavaCCParser)

package jminusminus;

import java.util.ArrayList;

/**
 * Parser generated by JavaCC. It parses a j-- compilation unit (program file), taking tokens from
 * the scanner (also generated by JavaCC), and produces an abstract syntax tree (AST) for it.
 */
class JavaCCParser {
    // Whether a parser error has been found.
    private boolean errorHasOccurred;

    // Name of the file that is parsed.
    private String fileName;

    /**
     * Sets the name of the file being parsed.
     *
     * @param fileName name of the file being parsed.
     */
    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Returns {@code true} if a parser error has occurred up to now, and {@code false} otherwise.
     *
     * @return {@code true} if a parser error has occurred up to now, and {@code false} otherwise.
     */
    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }

    // Pulls out and returns the ambiguous part of a name.
    private AmbiguousName ambiguousPart(TypeName name) {
        String qualifiedName = name.toString();
        int i = qualifiedName.lastIndexOf('.');
        return i == -1 ? null : new AmbiguousName(name.line(), qualifiedName.substring(0, i));
    }

    // Reports a syntax error.
    private void reportParserError(String message, Object... args) {
        errorHasOccurred = true;
        System.err.printf("%s:%d: error: ", fileName, token.beginLine);
        System.err.printf(message, args);
        System.err.println();
    }

    // Recover from the parser error that occurred by skipping to any of the specified tokens.
    // Current error recovery mechanism is rather simple-minded and is based on skipping all the
    // tokens until a SEMI or an EOF is encountered. This scheme can be enhanced by passing in the
    // FOLLOW-SET of the non-terminal at hand.
    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens.
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                expected.append("\n");
                expected.append("    ");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message.
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought", getToken(1), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought", getToken(1), expected);
        }

        // Recover.
        boolean loop = true;
        do {
            token = getNextToken(); 
            for (int i = 0; i < skipTo.length; i++) {
                if (token.kind == skipTo[i]) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }
}

PARSER_END(JavaCCParser)

/////////////////////////////////////////////////////////
//         The j-- lexical grammar starts here         //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: { " " | "\t" | "\n" | "\r" | "\f" }

// Single line comment -- ignored
SKIP: { <BEGIN_COMMENT: "//">: IN_SINGLE_LINE_COMMENT }
<IN_SINGLE_LINE_COMMENT>
SKIP: { <END_COMMENT: "\n" | "\r" | "\r\n">: DEFAULT }
<IN_SINGLE_LINE_COMMENT>
SKIP: { <COMMENT: ~[]> }

// Multiline comment -- ignored
SKIP: { <BEGIN_MULT_COMMENT: "/*">: MULTILINE_COMMENT }
<MULTILINE_COMMENT>
SKIP: { <END_MULT_COMMENT1: "*/">: DEFAULT }
<MULTILINE_COMMENT>
SKIP: { <MULT_COMMENT: ~[]> }

// Reserved words
TOKEN: {
  <ABSTRACT: "abstract">
| <BOOLEAN: "boolean">
// I added the reserved word break
| <BREAK: "break">
// I added the reserved word case
| <CASE: "case">
// I added the reserved word catch
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
// I added the reserved word continue
| <CONTINUE: "continue">
// I added the reserved word default
| <DEFAULT1: "default">
// I added the reserved word do
| <DO: "do">
// I added the reserved word double
| <DOUBLE: "double">
| <ELSE: "else">
| <EXTENDS: "extends">
| <FALSE: "false">
// I added the reserved word finally
| <FINALLY: "finally">
// I added the reserved word for
| <FOR: "for">
| <IF: "if">
// I added the reserved word implements
| <IMPLEMENTS: "implements">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
// I added the reserved word interface
| <INTERFACE: "interface">
// I added the reserved word long
| <LONG: "long">
| <NEW: "new">
| <NULL: "null">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <STATIC: "static">
| <SUPER: "super">
// I added the reserved word switch
| <SWITCH: "switch">
| <THIS: "this">
// I added the reserved word throw
| <THROW: "throw">
// I added the reserved word throws
| <THROWS: "throws">
| <TRUE: "true">
// I added the reserved word try
| <TRY: "try">
| <VOID: "void">
| <WHILE: "while">
}

// Separators
TOKEN: {
  <COMMA: ",">
| <DOT: ".">
| <LBRACK: "[">
| <LCURLY: "{">
| <LPAREN: "(">
| <RPAREN: ")">
| <RBRACK: "]">
| <RCURLY: "}">
| <SEMI: ";">
}

// Operators
TOKEN: {
  // I added here the operators that were missing and I tried to keep the order
  // the book is keeping.
  // I added the question "?"
  <QUESTION: "?">
  // I added the colon ":"
| <COLON: ":">
| <ASSIGN: "=">
| <EQUAL: "==">
| <LNOT: "!">
// I added the bitwise not "~"
| <BNOT: "~">
// I added the logical not assign "!="
| <NOT_EQUAL: "!=">
// I added the div "/"
| <DIV: "/">
// I added the div assign "/="
| <DIV_ASSIGN: "/=">
| <PLUS: "+">
| <PLUS_ASSIGN: "+=">
| <INC: "++">
| <MINUS: "-">
// I added the minus assign "-="
| <MINUS_ASSIGN: "-=">
| <DEC: "--">
| <STAR: "*">
// I added the star assign "*="
| <STAR_ASSIGN: "*=">
// I added the remainder "%"
| <REM: "%">
// I added the remainder assign "%="
| <REM_ASSIGN: "%=">
// I added the ARSHIFT ">>"
| <ARSHIFT: ">>">
// I added the ARSHIFT assign ">>="
| <ARSHIFT_ASSIGN: ">>=">
// I added the LRSHIFT ">>>"
| <LRSHIFT: ">>>">
// I added the LRSHIFT assign ">>>="
| <LRSHIFT_ASSIGN: ">>>=">
// I added the greater equal ">="
| <GE: ">=">
| <GT: ">">
// I added the ALSHIFT "<<"
| <ALSHIFT: "<<">
// I added the ALSHIFT assign "<<="
| <ALSHIFT_ASSIGN: "<<=">
| <LE: "<=">
// I added the less than "<"
| <LT: "<">
// I added the bitwise exclusive or "^"
| <BXOR: "^">
// I added the bitwise exclusive or assign "^="
| <BXOR_ASSIGN: "^=">
// I added the bitwise or "|"
| <BOR: "|">
// I dded the bitwise or assign "|="
| <BOR_ASSIGN: "|=">
// I added the logical or "||"
| <LOR: "||">
// I added the bitwise and "&"
| <BAND: "&">
// I added the bitwise and assign "&="
| <BAND_ASSIGN: "&=">
| <LAND: "&&">
}

// Identifiers
TOKEN: {
  <IDENTIFIER: ( <LETTER> | "_" | "$" ) ( <LETTER> | <DIGIT> | "_" | "$" )*>
| <#LETTER: [ "a"-"z", "A"-"Z" ]>
| <#DIGIT: [ "0"-"9" ]>
}

// Literals
TOKEN: {
  <INT_LITERAL: <DIGIT> ( <DIGIT> )*>
// I added the long literal option below
| <LONG_LITERAL: <INT_LITERAL> ( "l" | "L" )>
// I added the double literal option below
| <#EXPONENT: ("e" | "E") ("+" | "-")? <DIGIT> (<DIGIT>)*>
| <#SUFFIX: ("d" | "D")>
| <DOUBLE_LITERAL: (<DIGIT> (<DIGIT>)* <DOT> ((<DIGIT>)*)? (<EXPONENT>)? (<SUFFIX>)?)
                   | (<DOT> <DIGIT> (<DIGIT>)* (<EXPONENT>)? (<SUFFIX>)?)
                   | (<DIGIT> (<DIGIT>)* <EXPONENT> (<SUFFIX>)?)
                   | (<DIGIT> (<DIGIT>)* (<EXPONENT>)? <SUFFIX>)>
| <CHAR_LITERAL: "'" ( <ESC> | ~[ "'", "\\" ] ) "'">
| <STRING_LITERAL: "\"" ( <ESC> | ~[ "\"", "\\" ] )* "\"">
| <#ESC: "\\" [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]>
}

// For anything else, we return an ERROR token. Without this definition the TokenManager will throw
// an Error when a lexical error occurs, making it impossible to recover from it. So we define this
// ERROR token.
TOKEN: { <ERROR: ~[]> }

/////////////////////////////////////////////////////////
//       The j-- syntactic grammar starts here         //
/////////////////////////////////////////////////////////

/**
 * Parses a compilation unit (a program file) and returns an AST for it.
 *
 * <pre>
 *   compilationUnit ::= [ PACKAGE qualifiedIdentifier SEMI ]
 *                       { IMPORT  qualifiedIdentifier SEMI }
 *                       { typeDeclaration }
 *                       EOF
 * </pre>
 *
 * @return an AST for a compilation unit.
 */
public JCompilationUnit compilationUnit():
{
    int line = 0;
    TypeName packageName = null;
    TypeName anImport = null;
    ArrayList<TypeName> imports = new ArrayList<TypeName>();
    JAST aTypeDeclaration = null;
    ArrayList<JAST> typeDeclarations = new ArrayList<JAST>();
}
{
    try {
        [
            <PACKAGE>
            { line = token.beginLine; }
            packageName = qualifiedIdentifier()
            <SEMI>
        ]
        (
            <IMPORT>
            { line = line == 0 ? token.beginLine : line; }
            anImport = qualifiedIdentifier()
            { imports.add(anImport); }
            <SEMI>
        )*
        (
            aTypeDeclaration = typeDeclaration()
            {
                line = line == 0 ? aTypeDeclaration.line() : line;
                typeDeclarations.add(aTypeDeclaration);
            }
        )*
        <EOF>
        { line = line == 0 ? token.beginLine : line; }
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JCompilationUnit(fileName, line, packageName, imports, typeDeclarations); }
}

/**
 * Parses and returns a qualified identifier.
 *
 * <pre>
 *   qualifiedIdentifier ::= IDENTIFIER { DOT IDENTIFIER }
 * </pre>
 *
 * @return a qualified identifier.
 */
private TypeName qualifiedIdentifier():
{
    int line = 0;
    String qualifiedIdentifier = "";
}
{
    try {
        <IDENTIFIER>
        {
            line = token.beginLine;
            qualifiedIdentifier = token.image;
        }
        (
            // Lookahead added to suppress JavaCC warnings.
            LOOKAHEAD (<DOT> <IDENTIFIER>)
            <DOT> <IDENTIFIER>
            { qualifiedIdentifier += "." + token.image; }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new TypeName(line, qualifiedIdentifier); }
}

/**
 * Parses a type declaration and returns an AST for it.
 *
 * <pre>
 *   typeDeclaration ::= modifiers ( classDeclaration | interfaceDeclaration )
 * </pre>
 *
 * @return an AST for a type declaration.
 */
private JAST typeDeclaration():
{
    ArrayList<String> mods = null;
    // changed the name classDeclaration to typeDeclaration
    JAST typeDeclaration = null;
    // I initially had JAST classDeclaration = null; and
    //JAST interfaceDeclaration = null; but that is not necessary

}
{
    try {
            // Got help from the professor for this error I was getting
            // It was saying that "class" found where "{" was sought
            // with the lookahead this issue was fixed
            // I also change the name to typeDeclaration because there is
            // no need to have two variable of the same type since
            // one or the other can be true.
            //I needed to group the modifiers with either class declaration or
            // interface declaration
            LOOKAHEAD(modifiers() <CLASS>)
            (
            mods = modifiers()
            typeDeclaration = classDeclaration(mods)
            ) |
            (
            mods = modifiers()
            typeDeclaration = interfaceDeclaration(mods)
            )

    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return typeDeclaration; }
}

/**
 * Parses and returns a list of modifiers.
 *
 * <pre>
 *   modifiers ::= { ABSTRACT | PRIVATE | PROTECTED | PUBLIC | STATIC }
 * </pre>
 *
 * @return a list of modifiers.
 */
private ArrayList<String> modifiers():
{
    ArrayList<String> mods = new ArrayList<String>();
    boolean scannedPUBLIC    = false;
    boolean scannedPROTECTED = false;
    boolean scannedPRIVATE   = false;
    boolean scannedSTATIC    = false;
    boolean scannedABSTRACT  = false;
}
{
    try {
        (
            <ABSTRACT>
            {
                mods.add("abstract");
                if (scannedABSTRACT) {
                    reportParserError("Repeated modifier: abstract");
                }
                scannedABSTRACT = true;
            } |
            <PRIVATE>
            {
                mods.add("private");
                if (scannedPRIVATE) {
                    reportParserError("Repeated modifier: private");
                }
                if (scannedPUBLIC || scannedPROTECTED) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPRIVATE = true;
            } |
            <PROTECTED>
            {
                mods.add("protected");
                if (scannedPROTECTED) {
                    reportParserError("Repeated modifier: protected");
                }
                if (scannedPUBLIC || scannedPRIVATE) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPROTECTED = true;
            } |
            <PUBLIC>
            {
                mods.add("public");
                if (scannedPUBLIC) {
                    reportParserError("Repeated modifier: public");
                }
                if (scannedPROTECTED || scannedPRIVATE) {
                    reportParserError("Access conflict in modifiers");
                }
                scannedPUBLIC = true;
            } |
            <STATIC>
            {
                mods.add("static");
                if (scannedSTATIC) {
                    reportParserError("Repeated modifier: static");
                }
                scannedSTATIC = true;
            }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return mods; }
}

/**
 * Parses a class declaration and returns an AST for it.
 *
 * <pre>
 *   classDeclaration ::= CLASS IDENTIFIER [ EXTENDS qualifiedIdentifier ]
 *                              [ IMPLEMENTS qualifiedIdentifier { COMMA qualifiedIdentifier } ] classBody
 * </pre>
 *
 * @param mods the class modifiers.
 * @return an AST for a class declaration.
 */
private JClassDeclaration classDeclaration(ArrayList<String> mods):
{
    int line = 0;
    String name = "";
    Type superClass = Type.OBJECT;
    ArrayList<JMember> classBody = null;
    // I added the following variables, a list and a superInt of type
    // TypeName for the optional IMPLEMENTS
    ArrayList<TypeName> superInterfaces = new ArrayList<TypeName>();
    TypeName superInt;
}
{
    try {
        <CLASS>
        { line = token.beginLine; }
        <IDENTIFIER>
        { name = token.image; }
        [
            <EXTENDS>
            superClass = qualifiedIdentifier()
        ]
        // Here is the optional IMPLEMENTS.
        [
            // The parsing starts with the reseved word IMPLEMENTS
            // which is followed by a list of 1 or more qualified
            // identifiers.
            <IMPLEMENTS>
            superInt = qualifiedIdentifier()
            { superInterfaces.add(superInt); }
            (
               <COMMA>
               superInt = qualifiedIdentifier()
               { superInterfaces.add(superInt); }
            )*
        ]
        classBody = classBody()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    // Here I have an if statement in which I check if the list
    // with the interfaces is empty or not. If the list is empty
    // then the argument for the super interfaces is null, otherwise
    // the argument is the list.
    { if (superInterfaces.isEmpty()) {
            return new JClassDeclaration(line, mods, name, superClass, null, classBody);
      }
      return new JClassDeclaration(line, mods, name, superClass, superInterfaces, classBody);
    }
}

/**
 * Parses an interface declaration and returns an AST for it.
 *
 * <pre>
 *   interfaceDeclaration ::= INTERFACE IDENTIFIER [ EXTENDS qualifiedIdentifier { COMMA qualifiedIdentifier} ]
 *                              interfaceBody
 * </pre>
 *
 * @return an AST for an interface declaration.
 */
private JInterfaceDeclaration interfaceDeclaration(ArrayList<String> mods):
{
    int line = 0;
    String name = "";
    // initialize to null according to professor's instructions in office hours
    ArrayList<TypeName> superInterfaces = null;
    ArrayList<JMember> interfaceb = null;
    TypeName superInt = null;
}
{
    try {
         // First parse the reserved word INTERFACE and get the line
         // this word has been encountered
         <INTERFACE>
         { line = token.beginLine; }
         // the interface is followed by an identifier and a token image
         <IDENTIFIER>
         { name = token.image; }
         // There can be an optional extends
         [
             // The EXTENDS is followed by a list of 1 or more qualified
             // identifiers
             <EXTENDS>
             superInt = qualifiedIdentifier()
             {
             // create the ArrayList here rather than on the first block
             superInterfaces = new ArrayList<TypeName>();
             superInterfaces.add(superInt);
             }
             (
                <COMMA>
                superInt = qualifiedIdentifier()
                { superInterfaces.add(superInt); }
             )*
         ]
         // There should be an interface body
         // Here, there's a call of the method interfaceBody()
         interfaceb = interfaceBody()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    {
      return new JInterfaceDeclaration(line, mods, name, superInterfaces, interfaceb);
    }
}
/**
 * Parses a class body and returns a list of members in the body.
 *
 * <pre>
 *   classBody ::= LCURLY { modifiers memberDecl } RCURLY
 * </pre>
 *
 * @return a list of members in the class body.
 */
private ArrayList<JMember> classBody():
{
    ArrayList<String> mods = null;
    JMember aMember        = null;
    ArrayList<JMember> members = new ArrayList<JMember>();
}
{
    try {
        <LCURLY>
        (
            mods = modifiers()
            aMember = memberDecl(mods)
            { members.add(aMember); }
        )*
        <RCURLY>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return members; }
}

/**
 * Parses an interface body and returns a list of members in the body.
 *
 * <pre>
 *   interfaceBody ::= LCURLY { modifiers interfaceMemberDecl } RCURLY
 * </pre>
 *
 * @return a list of members in the class body.
 */
private ArrayList<JMember> interfaceBody():
{
    // same variables with the classBody() method
    ArrayList<String> mods = null;
    JMember aMember        = null;
    ArrayList<JMember> members = new ArrayList<JMember>();
}
{
    try {
        // This part is also the same with the classBody() method
        <LCURLY>
        (
            mods = modifiers()
            // I am only checking to see if the modifiers contain
            // ABSTRACT. If they are not, I am added ABSTRACT in
            // the list, because interfaces are abstract
            { if (!mods.contains(ABSTRACT)) {
                  mods.add(String.valueOf("abstract"));
              }
            }
            aMember = interfaceMemberDecl(mods)
            { members.add(aMember); }
        )*
        <RCURLY>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return members; }
}
/**
 * Parses a member declaration and returns an AST for it.
 *
 * <pre>
 *   memberDecl ::= IDENTIFIER formalParameters [ THROWS qualifiedIdentifier { COMMA qualifiedIdentifier } ] block
 *                | ( VOID | type ) IDENTIFIER formalParameters
 *                                [ THROWS qualifiedIdentifier { COMMA qualifiedIdentifier } ] ( block | SEMI )
 *                | type variableDeclarators SEMI
 * </pre>
 *
 * @param mods the class member modifiers.
 * @return an AST for a member declaration.
 */
private JMember memberDecl(ArrayList<String> mods):
{
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    JBlock body = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
    // I added the list exceptions
    ArrayList<TypeName> exceptions = null;
    TypeName exception = null;
}
{
    try {
        LOOKAHEAD(<IDENTIFIER> <LPAREN>)
        (
            <IDENTIFIER>
            {
                line = token.beginLine;
                name = token.image;
            }
            params = formalParameters()
            // I added the optional THROWS for the constructor
            [
                // I start by parsing the reserved word THROWS
                // which is followed by a list of 1 or more
                // qualified identifiers
                <THROWS>
                exception = qualifiedIdentifier()
                {
                    // creating the new array here
                    exceptions= new ArrayList<TypeName>();
                    exceptions.add(exception);
                }
                (
                    <COMMA>
                    exception = qualifiedIdentifier()
                    { exceptions.add(exception); }
                )*
            ]
            body = block()
            // where the exceptions is in following line, there used to be null
            { memberDecl = new JConstructorDeclaration(line, mods, name, params, exceptions, body); }
        ) |
        LOOKAHEAD((<VOID> | type()) <IDENTIFIER> <LPAREN>)
        (
            (
                <VOID>
                { type = Type.VOID; } |
                type = type()
            )
            { line = token.beginLine; }
            <IDENTIFIER>
            { name = token.image; }
            params = formalParameters()
            // This is an optional THROWS for the method declaration
            [
                // I start my parsing with the reserved word THROWS
                // which is followed by a list of 1 or more qualified
                // identifiers
                <THROWS>
                exception = qualifiedIdentifier()
                { exceptions = new ArrayList<TypeName>();
                exceptions.add(exception); }
                (
                    <COMMA>
                    exception = qualifiedIdentifier()
                    { exceptions.add(exception); }
                )*
            ]
            (
                body = block() |
                <SEMI>
            )
            // Where the exceptions is in the following line, there used to be a null
            { memberDecl = new JMethodDeclaration(line, mods, name, type, params, exceptions, body); }
        ) |
        (
            type = type()
            { line = token.beginLine; }
            variableDeclarators = variableDeclarators(type)
            { memberDecl = new JFieldDeclaration(line, mods, variableDeclarators); }
            <SEMI>
        )
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return memberDecl; }
}

/**
 * Parses an interface member declaration and returns an AST for it.
 *
 * <pre>
 *   interfaceMemberDecl ::= ( VOID | type ) IDENTIFIER formalParameters
 *                                  [ THROWS qualifiedIdentifier { COMMA qualifiedIdentifier } ] SEMI
 *                          | type variableDeclarators SEMI
 * </pre>
 *
 * @param mods the interface member modifiers.
 * @return an AST for an interface member declaration.
 */
private JMember interfaceMemberDecl(ArrayList<String> mods):
{
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember interfaceMemberDecl = null;
    // I added a list that will contain qualified identifiers
    ArrayList<TypeName> exceptions = null;
    TypeName exception = null;
}
{
    try {
        // Took this part from the memberDecl() method above
        LOOKAHEAD((<VOID> | type()) <IDENTIFIER> <LPAREN> )
        (
            (
               <VOID>
                { type = Type.VOID; } |
                type = type()
            )
            { line = token.beginLine; }
            <IDENTIFIER>
            { name = token.image; }
            params = formalParameters()
            // I also got this part from the memberlDecl() method
            // after I implemented the exception handlers problem
            [
                <THROWS>
                exception = qualifiedIdentifier()
                { exceptions = new ArrayList<TypeName>();
                exceptions.add(exception); }
                (
                    <COMMA>
                    exception = qualifiedIdentifier()
                    { exceptions.add(exception); }
                )*
            ]
            <SEMI>
            { interfaceMemberDecl = new JMethodDeclaration(line, mods, name, type, params, exceptions, null); }
        ) |
        (
            type = type()
            { line = token.beginLine; }
            variableDeclarators = variableDeclarators(type)
            <SEMI>
            { interfaceMemberDecl = new JFieldDeclaration(line, mods, variableDeclarators); }
        )
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return interfaceMemberDecl; }
}

/**
 * Parses a block and returns an AST for it.
 *
 * <pre>
 *   block ::= LCURLY { blockStatement } RCURLY
 * </pre>
 *
 * @return an AST for a block.
 */
private JBlock block():
{
    int line = 0;
    JStatement aStatement = null;
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
}
{
    try {
        <LCURLY>
        { line = token.beginLine; }
        (
            aStatement = blockStatement()
            { statements.add(aStatement); }
        )*
        <RCURLY>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JBlock(line, statements); }
}

/**
 * Parses a block statement and returns an AST for it.
 *
 * <pre>
 *   blockStatement ::= localVariableDeclarationStatement
 *                    | statement
 * </pre>
 *
 * @return an AST for a block statement.
 */
private JStatement blockStatement():
{
    JStatement statement = null;
}
{
    try {
        LOOKAHEAD(type() <IDENTIFIER>)
        statement = localVariableDeclarationStatement() |
        statement = statement()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statement; }
}

/**
 * Parses a statement and returns an AST for it.
 *
 * <pre>
 *   statement ::= block
 *               | BREAK SEMI
 *               | CONTINUE SEMI
 *               | DO statement WHILE parExpression SEMI
 *               | FOR LPAREN [ forInit ] SEMI [ expression ] SEMI [ forUpdate ] RPAREN statement
 *               | IF parExpression statement [ ELSE statement ]
 *               | RETURN [ expression ] SEMI
 *               | SEMI
 *               | SWITCH parExpression LCURLY { switchBlockStatementGroup } RCURLY
 *               | THROW expression SEMI
 *               | TRY block { CATCH LPAREN formalParameter RPAREN block } [ FINALLY block ]
 *               | WHILE parExpression statement
 *               | statementExpression SEMI
 * </pre>
 *
 * @return an AST for a statement.
 */
private JStatement statement():
{
    int line = 0;
    JStatement statement  = null;
    JExpression test      = null;
    JStatement consequent = null;
    JStatement alternate  = null;
    JStatement body       = null;
    JExpression expr      = null;
    // I have added the following lines recently
    // the tryBlock is needed for the exception handlers
    JBlock tryBlock = null;
    // the finallyBlock is needed for the exception handlers
    JBlock finallyBlock = null;
    JFormalParameter param = null;
    // the catchBlock is needed for the exception handlers
    JBlock catchBlock = null;
    ArrayList<JFormalParameter> params = new ArrayList<JFormalParameter>();
    // The catchBlocks is needed for the exception handlers
    ArrayList<JBlock> catchBlocks = new ArrayList<JBlock>();
    // The init list is needed for the FOR statement
    ArrayList<JStatement> init = null;
    // The update list is needed for the FOR statement
    ArrayList<JStatement> update = null;
    // The stmtGroup list is needed for the SWITCH statement
    ArrayList<SwitchStatementGroup> stmtGroup = new ArrayList<SwitchStatementGroup>();
    // The switchgroup is needed for the SWITCH statement
    SwitchStatementGroup switchgroup = null;
}
{
    try {
        statement = block() |
        // I added the option for the break here
        // take the reserved word BREAK first along with the line
        // number the break statement starts
        <BREAK>
        { line = token.beginLine; }
        // break is always followed by a SEMI
        <SEMI>
        { statement = new JBreakStatement(line); } |
        // I added the option for the continue here
        // take the reserved word CONTINUE first along with the line
        // number the continue statement starts
        <CONTINUE>
        { line = token.beginLine; }
        // continue is always followed by a SEMI
        <SEMI>
        { statement = new JContinueStatement(line); } |
        // I added the option for the do while statement here
        // take the reserved word DO first along with the lune
        // number the do-while statement starts
        <DO>
        { line = token.beginLine; }
        // after the reserved word DO we get the body
        body = statement()
        // there must be a WHILE
        <WHILE>
        // WHILE must be followed by a parenthesized expression
        test = parExpression()
        // the do-while statement should end with a SEMI
        <SEMI>
        { statement = new JDoStatement(line, body, test); } |
        // I added the option for the for loop here
        // The for loop starts with the reserved word FOR along
        // with the line the for loop statement begins
        <FOR>
        { line = token.beginLine; }
        // a left parenthesis must be present and followed by
        // 0 or 1 init.
        <LPAREN>
        [
            init = forInit()
        ]
        // the init is always followed by a SEMI
        <SEMI>
        // after the semi we can have 0 or 1 expression
        [
            expr = expression()
        ]
        // there should be a SEMI after an expression, even if it exists
        // or not
        <SEMI>
        // after the second SEMI we can have 0 or 1 update which
        // should be followed by a right parenthesis
        [
            update = forUpdate()
        ]
        <RPAREN>
        // Lastly, there should be statement
        statement = statement()
        { statement = new JForStatement(line, init, expr, update, statement); } |
        <IF>
        { line = token.beginLine; }
        test = parExpression()
        consequent = statement()
        // Even without the lookahead below, which is added to suppress JavaCC warnings, dangling
        // if-else problem is resolved by binding the alternate to the closest consequent.
        [
            LOOKAHEAD(<ELSE>)
            <ELSE>
            alternate = statement()
        ]
        { statement = new JIfStatement(line, test, consequent, alternate); } |
        <RETURN>
        { line = token.beginLine; }
        [
            expr = expression()
        ]
        <SEMI>
        { statement = new JReturnStatement(line, expr); } |
        <SEMI>
        {
            line = token.beginLine;
            statement = new JEmptyStatement( line );
        } |
        // I added the switch statement here
        // Firstly, I am getting the reserved word SWITCH along with
        // the line number where the switch statement started
        <SWITCH>
        { line = token.beginLine; }
        // after the reserved word SWITCH, we have a parenthesized expression
        test = parExpression()
        // a parenthesized expression is followed by a left curly bracket
        // which is followed by 0 or more switchBlockStatementGroups
        <LCURLY>
        (
            switchgroup = switchBlockStatementGroup()
            { stmtGroup.add(switchgroup); }
        )*
        // after the switchBlockStatementGroup we have a right curly bracket
        <RCURLY>
        { statement = new JSwitchStatement(line, test, stmtGroup); } |
        // This is the option for the throw
        // Firstly, I am getting the reserved word THROW along with the
        // line number the THROW starts
        <THROW>
        { line = token.beginLine; }
        // The THROW is followed by ab expression which is followed by a SEMI
        expr = expression()
        <SEMI>
        { statement = new JThrowStatement(line, expr); } |
        // I This is the option for the TRY-CATCH exception handler
        // I start by parsing the reserved word TRY along with the
        // line number the TRY starts
        <TRY>
        { line = token.beginLine; }
        // TRY is followed by a block which I named tryBlock
        tryBlock = block()
        // the try block is followed 0 or more catch blocks
        (
            // A catch block starts with the reserved word CATCH
            // which is followed by an LPAREN a list of formal
            // parameters a RPAREN, an a list of blocks
            <CATCH>
            <LPAREN>
            param = formalParameter()
            { params.add(param); }
            <RPAREN>
            catchBlock = block()
            { catchBlocks.add(catchBlock); }
        )*
        // we could also encounter 0 or 1 FINALLY blocks
        // A finally block starts with the reserved word FINALLY
        // which is followed by a block
        [
        <FINALLY>
        finallyBlock = block()
        ]
        { statement = new JTryStatement(line, tryBlock, params, catchBlocks, finallyBlock); } |
        <WHILE>
        { line = token.beginLine; }
        test = parExpression()
        body = statement()
        { statement = new JWhileStatement(line, test, body); } |
        // Must be a statementExpression.
        statement = statementExpression()
        <SEMI>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statement; }
}

/**
 * Parses and returns a list of formal parameters.
 *
 * <pre>
 *   formalParameters ::= LPAREN [ formalParameter { COMMA  formalParameter } ] RPAREN
 * </pre>
 *
 * @return a list of formal parameters.
 */
private ArrayList<JFormalParameter> formalParameters():
{
    ArrayList<JFormalParameter> parameters = new ArrayList<JFormalParameter>();
    JFormalParameter aParameter = null;
}
{
    try {
        <LPAREN>
        [
            aParameter = formalParameter()
            { parameters.add(aParameter); }
            (
                <COMMA>
                aParameter = formalParameter()
                { parameters.add(aParameter); }
            )*
        ]
        <RPAREN>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return parameters; }
}

/**
 * Parses a formal parameter and returns an AST for it.
 *
 * <pre>
 *   formalParameter ::= type IDENTIFIER
 * </pre>
 *
 * @return an AST for a formal parameter.
 */
private JFormalParameter formalParameter():
{
    int line    = 0;
    Type type   = null;
    String name = "";
}
{
    try {
        type = type()
        { line = token.beginLine; }
        <IDENTIFIER>
        { name = token.image; }
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JFormalParameter(line, name, type); }
}

/**
 * Parses a parenthesized expression and returns an AST for it.
 *
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 *
 * @return an AST for a parenthesized expression.
 */
private JExpression parExpression():
{
    JExpression expr = null;
}
{
    try {
        <LPAREN>
        expr = expression()
        <RPAREN>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses and returns a list of forInit statement expressions or a single variable declarator.
 *
 * <pre>
 *   forInit ::= statementExpression { COMMA statementExpression }
 *              | type variableDeclarators
 * </pre>
 *
 * @return a list of statement expressions or a single variable declarator in a form a list.
 */
private ArrayList<JStatement> forInit():
{
    // Here are the variables needed for the forInit() method
    // and list that will hold the statement expressions or the
    // the single variable declarator
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
    // needed to get the variable declarator
    ArrayList<JVariableDeclarator> vdecls = null;
    JStatement statement = null;
    int line = 0;
    Type type = null;
}
{
    try {
        // add 1 or more statement expressions in the statements list
        statement = statementExpression()
        { statements.add(statement); }
        (
            <COMMA>
            statement = statementExpression()
            { statements.add(statement); }
        )* |
        // add the single variable declarator in the list od the statements
        { line = token.beginLine; }
        type = type()
        { vdecls = variableDeclarators(type); }
        { statements.add(new JVariableDeclaration(line, vdecls)); }
    } catch (ParseException e) {
              recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statements; }
}

/**
 * Parses and returns a list of statement Expressions that are specifically for the update part
 * of a for loop
 *
 * <pre>
 *   forUpdate ::= statementExpression { COMMA statementExpression }
 * </pre>
 *
 * @return a list of statement expressions.
 */
private ArrayList<JStatement> forUpdate():
{
    // These are the variables needed for the forUpdate() method
    // This is the list that will contain all the necessary statements
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
    JStatement statement = null;
}
{
    try {
        // add in the statements list 1 or more statement expressions
        statement = statementExpression()
        { statements.add(statement); }
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return statements; }
}

/**
* Parses a switch block statement group and returns an AST for it.
*
* <pre>
*   switchBlockStatementGroup ::= switchLabel {switchLabel} {blockStatement}
* </pre>
*
* @return an AST for a switch block statement group
*/
private SwitchStatementGroup switchBlockStatementGroup():
{
    // I added to this block the variables that are needed for the
    // switchBlockStatementGroup
    // I need a labels list
    ArrayList<JExpression> labels = new ArrayList<JExpression>();
    // I need a statement blocks list
    ArrayList<JStatement> stmtBlock = new ArrayList<JStatement>();
    JExpression label = null;
    JStatement stmblock = null;
}
{
    try {
        // I am adding 1 or more labels in the labels list
        label = switchLabel()
        { labels.add(label); }
        (
            label = switchLabel()
            { labels.add(label); }
        )*
        // I am adding 0 or more block statements in the stmtBlock list
        (
            stmblock = blockStatement()
            { stmtBlock.add(stmblock); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new SwitchStatementGroup(labels, stmtBlock); }
}

/**
 * Parses a switch label and returns an AST for it.
 *
 * <pre>
 *   switchLabel ::= CASE expression COLON
 *                  | DEFAULT COLON
 * </pre>
 *
 * @return an AST for a switch label.
 */
private JExpression switchLabel():
{
    JExpression expr = null;
}
{
    try {
        <CASE>
        expr = expression()
        <COLON> |
        <DEFAULT1>
        <COLON>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses a local variable declaration statement and returns an AST for it.
 *
 * <pre>
 *   localVariableDeclarationStatement ::= type variableDeclarators SEMI
 * </pre>
 *
 * @return an AST for a local variable declaration statement.
 */
private JVariableDeclaration localVariableDeclarationStatement():
{
    int line = 0;
    Type type = null;
    ArrayList<JVariableDeclarator> vdecls = null;
}
{
    try {
        type = type()
        { line = token.beginLine; }
        vdecls = variableDeclarators(type)
        <SEMI>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JVariableDeclaration(line, vdecls); }
}

/**
 * Parses and returns a list of variable declarators.
 *
 * <pre>
 *   variableDeclarators ::= variableDeclarator { COMMA variableDeclarator }
 * </pre>
 *
 * @param type type of the variables.
 * @return a list of variable declarators.
 */
private ArrayList<JVariableDeclarator> variableDeclarators(Type type):
{
    JVariableDeclarator aVariableDeclarator = null;
    ArrayList<JVariableDeclarator> variableDeclarators = new ArrayList<JVariableDeclarator>();
}
{
    try {
        aVariableDeclarator = variableDeclarator(type)
        { variableDeclarators.add(aVariableDeclarator); }
        (
            <COMMA>
            aVariableDeclarator = variableDeclarator(type)
            { variableDeclarators.add(aVariableDeclarator); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return variableDeclarators; }
}

/**
 * Parses a variable declarator and returns an AST for it.
 *
 * <pre>
 *   variableDeclarator ::= IDENTIFIER [ ASSIGN variableInitializer ]
 * </pre>
 *
 * @param type type of the variable.
 * @return an AST for a variable declarator.
 */
private JVariableDeclarator variableDeclarator(Type type):
{
    int line = 0;
    JExpression initial = null;
    String name = "";
}
{
    try {
        <IDENTIFIER>
        {
            line = token.beginLine;
            name = token.image;
        }
        [
            <ASSIGN>
            initial = variableInitializer(type)
        ]
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JVariableDeclarator(line, name, type, initial); }
}

/**
 * Parses a variable initializer and returns an AST for it.
 *
 * <pre>
 *   variableInitializer ::= arrayInitializer | expression
 * </pre>
 *
 * @param type type of the variable.
 * @return an AST for a variable initializer.
 */
private JExpression variableInitializer(Type type):
{
    JExpression initializer = null;
}
{
    try {
        initializer = arrayInitializer(type) |
        initializer = expression()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return initializer; }
}

/**
 * Parses an array initializer and returns an AST for it.
 *
 * <pre>
 *   arrayInitializer ::= LCURLY [variableInitializer {COMMA variableInitializer} [COMMA]] RCURLY
 * </pre>
 *
 * @param type type of the array.
 * @return an AST for an array initializer.
 */
private JArrayInitializer arrayInitializer(Type type):
{
    int line = 0;
    ArrayList<JExpression> initials = new ArrayList<JExpression>();
    JExpression anInitializer = null;
}
{
    try {
        <LCURLY>
        { line = token.beginLine; }
        [
            anInitializer = variableInitializer(type.componentType())
            { initials.add(anInitializer); }
            (
                <COMMA>
                anInitializer = variableInitializer(type.componentType())
                { initials.add(anInitializer); }
            )*
        ]
        <RCURLY>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JArrayInitializer(line, type, initials); }
}

/**
 * Parses and returns a list of arguments.
 *
 * <pre>
 *   arguments ::= LPAREN [ expression { COMMA expression } ] RPAREN
 * </pre>
 *
 * @return a list of arguments.
 */
private ArrayList<JExpression> arguments():
{
    ArrayList<JExpression> args = new ArrayList<JExpression>();
    JExpression anExpression = null;
}
{
    try {
        <LPAREN>
        [
            anExpression = expression()
            { args.add(anExpression); }
            (
                <COMMA>
                anExpression = expression()
                { args.add(anExpression); }
            )*
        ]
        <RPAREN>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return args; }
}

/**
 * Parses and returns a type.
 *
 * <pre>
 *   type ::= referenceType | basicType
 * </pre>
 *
 * @return a type.
 */
private Type type():
{
    Type type = null;
}
{
    try {
        LOOKAHEAD(<IDENTIFIER> | basicType() <LBRACK> <RBRACK>)
        type = referenceType() |
        type = basicType()
    } catch (ParseException e) {
       recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return type; }
}

/**
 * Parses and returns a basic type.
 *
 * <pre>
 *   basicType ::= BOOLEAN | CHAR | INT | LONG | DOUBLE
 * </pre>
 *
 * @return a basic type.
 */
private Type basicType():
{
    Type type = Type.ANY;
}
{
    try {
        <BOOLEAN>
        { type = Type.BOOLEAN; } |
        <CHAR>
        { type = Type.CHAR; } |
        // I added the double basic type
        <DOUBLE>
        { type = Type.DOUBLE; } |
        <INT>
        { type = Type.INT; } |
        // I added the long basic type
        <LONG>
        { type = Type.LONG; }
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    {
        if (type == Type.ANY) {
            reportParserError("Type sought where %s found", token.image);
        }
        return type;
    }
}

/**
 * Parses and returns a reference type.
 *
 * <pre>
 *   referenceType ::= basicType LBRACK RBRACK { LBRACK RBRACK }
 *                   | qualifiedIdentifier { LBRACK RBRACK }
 * </pre>
 *
 * @return a reference type.
 */
private Type referenceType():
{
    Type type = Type.ANY;
}
{
    try {
        type = basicType()
        <LBRACK> <RBRACK>
        { type = new ArrayTypeName(type); }
        (
            <LBRACK> <RBRACK>
            { type = new ArrayTypeName(type); }
        )* |
        type = qualifiedIdentifier()
        (
            <LBRACK> <RBRACK>
            { type = new ArrayTypeName(type); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return type; }
}

/**
 * Parses a statement expression and returns an AST for it.
 *
 * <pre>
 *   statementExpression ::= expression
 * </pre>
 *
 * @return an AST for a statement expression.
 */
private JStatement statementExpression():
{
    int line = 0;
    JExpression expr = null;
}
{
    try {
        expr = expression()
        {
            line = expr.line();
            if (expr instanceof JAssignment
             || expr instanceof JPreIncrementOp
             || expr instanceof JPostDecrementOp
             || expr instanceof JMessageExpression
             || expr instanceof JSuperConstruction
             || expr instanceof JThisConstruction 
             || expr instanceof JNewOp
             || expr instanceof JNewArrayOp
             // added this line for the For loop
             || expr instanceof JStatement) {
                // So as not to save on stack.
                expr.isStatementExpression = true;
            } else {
                reportParserError("Invalid statement expression; it does not have a side-effect");
            }
        }
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JStatementExpression( line, expr ); }
}

/**
 * Parses an expression and returns an AST for it.
 *
 * <pre>
 *   expression ::= assignmentExpression
 * </pre>
 *
 * @return an AST for an expression.
 */
private JExpression expression():
{
    JExpression expr = null;
}
{
    try {
        expr = assignmentExpression()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses an assignment expression and returns an AST for it.
 *
 * <pre>
 *   assignmentExpression ::= conditionalExpression
 *                                [ ( ALSHIFT_ASSIGN | BAND_ASSIGN | ARSHIFT_ASSIGN | ASSIGN | DIV_ASSIGN |
 *                                    LRSHIFT_ASSIGN | MINUS_ASSIGN | BOR_ASSIGN | PLUS_ASSIGN | REM_ASSIGN
 *                                    STAR_ASSIGN | BXOR_ASSIGN ) assignmentExpression ]
 * </pre>
 *
 * @return an AST for an assignment expression.
 */
private JExpression assignmentExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalExpression()
        { line = lhs.line(); }
        [
            // I added the option for arithmetic left assign
            <ALSHIFT_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JALeftShiftAssignOp(line, lhs, rhs); } |
            // I added the option for and assign
            <BAND_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JAndAssignOp(line, lhs, rhs); } |
            // I added the option for arithmetic right assign
            <ARSHIFT_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JARightShiftAssignOp(line, lhs, rhs); } |
            <ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JAssignOp(line, lhs, rhs); } |
            // I added the option for div assign
            <DIV_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JDivAssignOp(line, lhs, rhs); } |
            // I added the option for logical right assign
            <LRSHIFT_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JLRightShiftAssignOp(line, lhs, rhs); } |
            // I added the option for minus assign
            <MINUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JMinusAssignOp(line, lhs, rhs); } |
            // I added the option for inclusive or assign
            <BOR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JOrAssignOp(line, lhs, rhs); } |
            <PLUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JPlusAssignOp(line, lhs, rhs); } |
            // I added the option for rem assign
            <REM_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JRemAssignOp(line, lhs, rhs); } |
            // I added the option for star assign
            <STAR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JStarAssignOp(line, lhs, rhs); } |
            // I added the option for exclusive or assign
            <BXOR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JXorAssignOp(line, lhs, rhs); }
        ]
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}
/**
 * Parses a conditional expression and returns an AST for it.
 *
 * <pre>
 *   conditionalExpression ::= conditionalOrExpression [ QUESTION expression COLON conditionalExpression ]
 * </pre>
 *
 * @return an AST for a conditional expression.
 */
 private JExpression conditionalExpression():
 {
     int line = 0;
     JExpression lhs = null, thenPart = null, elsePart = null;
 }
 {
    try {
       lhs = conditionalOrExpression()
       { line = lhs.line(); }
       // having 0 or 1 options of a <QUESTION>, followed by an expression
       // which is followed by a <COLON>, which is also followed by a conditional
       // expression.
        [
            <QUESTION>
            thenPart = expression()
            <COLON>
            elsePart = conditionalExpression()
            { lhs = new JConditionalExpression(line, lhs, thenPart, elsePart); }
        ]
    } catch (ParseException e) {
       recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
 }
/**
 * Parses a conditional-or expression and returns an AST for it.
 *
 * <pre>
 *   conditionalOrExpression ::= conditionalAndExpression { LOR conditionalAndExpression }
 * </pre>
 *
 * @return an AST for a conditional-or expression.
 */
private JExpression conditionalOrExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalAndExpression()
        { line = lhs.line(); }
        (
            // This is the conditional or operator
            <LOR>
            rhs = conditionalAndExpression()
            { lhs = new JLogicalOrOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}
/**
 * Parses a conditional-and expression and returns an AST for it.
 *
 * <pre>
 *   conditionalAndExpression ::= inclusiveOrExpression { LAND inclusiveOrExpression }
 * </pre>
 *
 * @return an AST for a conditional-and expression.
 */
private JExpression conditionalAndExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = inclusiveOrExpression()
        { line = lhs.line(); }
        (
            <LAND>
            rhs = inclusiveOrExpression()
            { lhs = new JLogicalAndOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses an inclusive-or expression and returns an AST for it.
 *
 * <pre>
 *   inclusiveOrExpression ::= exclusiveOrExpression { BOR exclusiveOrExpression }
 * </pre>
 *
 * @return an AST for an inclusive-or expression.
 */
private JExpression inclusiveOrExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = exclusiveOrExpression()
        { line = lhs.line(); }
        (
            // This is the inclusive or operator
            <BOR>
            rhs = exclusiveOrExpression()
            { lhs = new JOrOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses an exclusive-or expression and returns an AST for it.
 *
 * <pre>
 *   exclusiveOrExpression ::= andExpression { BXOR andExpression }
 * </pre>
 *
 * @return an AST for an exclusive-or expression.
 */
private JExpression exclusiveOrExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = andExpression()
        { line = lhs.line(); }
        (
            // This is the exclusive or operator
            <BXOR>
            rhs = andExpression()
            { lhs = new JXorOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}
/**
 * Parses an and expression and returns an AST for it.
 *
 * <pre>
 *   andExpression ::= equalityExpression { BAND equalityExpression }
 * </pre>
 *
 * @return an AST for an and expression.
 */
private JExpression andExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = equalityExpression()
        { line = lhs.line(); }
        (
            // This is the bitwise and operator
            <BAND>
            rhs = equalityExpression()
            { lhs = new JAndOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses an equality expression and returns an AST for it.
 *
 * <pre>
 *   equalityExpression ::= relationalExpression { EQUAL | NOT_EQUAL relationalExpression }
 * </pre>
 *
 * @return an AST for an equality expression.
 */
private JExpression equalityExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = relationalExpression()
        { line = lhs.line(); }
        (
            <EQUAL>
            rhs = relationalExpression()
            { lhs = new JEqualOp(line, lhs, rhs); } |
            // I added the option for not equal
            <NOT_EQUAL>
            rhs = relationalExpression()
            { lhs = new JNotEqualOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses a relational expression and returns an AST for it.
 *
 * <pre>
 *   relationalExpression ::= shiftExpression [ ( GE| GT | LE | LT ) shiftExpression
 *                                               | INSTANCEOF referenceType ]
 * </pre>
 *
 * @return an AST for a relational expression.
 */
private JExpression relationalExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
    Type type = null;
}
{
    try {
        lhs = shiftExpression() { line = lhs.line(); }
        [
            // I added the option for greater equal
            <GE>
            rhs = shiftExpression()
            { lhs = new JGreaterEqualOp(line, lhs, rhs); } |
            <GT>
            rhs = shiftExpression()
            { lhs = new JGreaterThanOp(line, lhs, rhs); } |
            <LE>
            rhs = shiftExpression()
            { lhs = new JLessEqualOp(line, lhs, rhs); } |
            // I added the option for less than
            <LT>
            rhs = shiftExpression()
            { lhs = new JLessThanOp(line, lhs, rhs); } |
            <INSTANCEOF>
            type = referenceType()
            { lhs = new JInstanceOfOp(line, lhs, type); }
        ]
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses a shift expression and returns an AST for it.
 *
 * <pre>
 *   shiftExpression ::= additiveExpression { ( ALSHIFT | ARSHIFT | LRSHIFT ) additiveExpression }
 *
 * </pre>
 *
 * @return an AST for a relational expression.
 */
private JExpression shiftExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
    Type type = null;
}
{
    try {
        lhs = additiveExpression()
        { line = lhs.line(); }
        (
            // This is the arithmetic left shift operator
            <ALSHIFT>
            rhs = additiveExpression()
            { lhs = new JALeftShiftOp(line, lhs, rhs); } |
            // This is the arithmentic right shift operator
            <ARSHIFT>
            rhs = additiveExpression()
            { lhs = new JARightShiftOp(line, lhs, rhs); } |
            // This is the logical right shift
            <LRSHIFT>
            rhs = additiveExpression()
            { lhs = new JLRightShiftOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses an additive expression and returns an AST for it.
 *
 * <pre>
 *   additiveExpression ::= multiplicativeExpression { ( MINUS | PLUS ) multiplicativeExpression }
 * </pre>
 *
 * @return an AST for an additive expression.
 */
private JExpression additiveExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = multiplicativeExpression()
        { line = lhs.line(); }
        (
            <MINUS>
            rhs = multiplicativeExpression()
            { lhs = new JSubtractOp(line, lhs, rhs); } |
            <PLUS>
            rhs = multiplicativeExpression()
            { lhs = new JPlusOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses a multiplicative expression and returns an AST for it.
 *
 * <pre>
 *   multiplicativeExpression ::= unaryExpression { STAR | DIV | REM unaryExpression }
 * </pre>
 *
 * @return an AST for a multiplicative expression.
 */
private JExpression multiplicativeExpression():
{
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = unaryExpression()
        { line = lhs.line(); }
        (
            <STAR>
            rhs = unaryExpression()
            { lhs = new JMultiplyOp(line, lhs, rhs); } |
            // I added the option for DIV
            <DIV>
            rhs = unaryExpression()
            { lhs = new JDivideOp(line, lhs, rhs); } |
            // I added the option for REM
            <REM>
            rhs = unaryExpression()
            { lhs = new JRemainderOp(line, lhs, rhs); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return lhs; }
}

/**
 * Parses an unary expression and returns an AST for it.
 *
 * <pre>
 *   unaryExpression ::= DEC unaryExpression
 *                     | INC unaryExpression
 *                     | ( MINUS | PLUS ) unaryExpression
 *                     | simpleUnaryExpression
 * </pre>
 *
 * @return an AST for an unary expression.
 */
private JExpression unaryExpression():
{
    int line = 0;
    JExpression expr = null, unaryExpr = null;
}
{
    try {
        // I added the option for the DEC In a similar way with the INC
        <DEC>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreDecrementOp(line, unaryExpr); } |
        <INC>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreIncrementOp(line, unaryExpr); } |
        <MINUS>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JNegateOp(line, unaryExpr); } |
        // I added the option for unary plus
        <PLUS>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JUnaryPlusOp(line, unaryExpr); } |
        expr = simpleUnaryExpression()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses a simple unary expression and returns an AST for it.
 *
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                           | BNOT unaryExpression
 *                           | LPAREN basicType RPAREN unaryExpression
 *                           | LPAREN referenceType RPAREN simpleUnaryExpression
 *                           | postfixExpression
 * </pre>
 *
 * @return an AST for a simple unary expression.
 */
private JExpression simpleUnaryExpression():
{
    int line = 0;
    Type type = null;
    JExpression expr = null, unaryExpr = null, simpleUnaryExpr = null;
}
{
    try {
        <LNOT>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JLogicalNotOp(line, unaryExpr); } |
        // I added the option for the complement
        <BNOT>
        { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JComplementOp(line, unaryExpr); } |
        LOOKAHEAD(<LPAREN> basicType() <RPAREN>)
        <LPAREN>
        { line = token.beginLine; }
        type = basicType()
        <RPAREN>
        unaryExpr = unaryExpression()
        { expr = new JCastOp(line, type, unaryExpr); } |
        LOOKAHEAD(<LPAREN> referenceType() <RPAREN>)
        <LPAREN>
        { line = token.beginLine; }
        type = referenceType()
        <RPAREN>
        simpleUnaryExpr = simpleUnaryExpression()
        { expr = new JCastOp(line, type, simpleUnaryExpr); } |
        expr = postfixExpression()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr ; }
}

/**
 * Parses a postfix expression and returns an AST for it.
 *
 * <pre>
 *   postfixExpression ::= primary { selector } { DEC | INC }
 * </pre>
 *
 * @return an AST for a postfix expression.
 */
private JExpression postfixExpression():
{
    int line = 0; 
    JExpression primaryExpr = null;
}
{
    try {
        primaryExpr = primary()
        { line = primaryExpr.line(); }
        (
            primaryExpr = selector(primaryExpr)
        )*
        (
            <DEC>
            { primaryExpr = new JPostDecrementOp(line, primaryExpr); } |
            // I added the option of the post increment
            <INC>
            { primaryExpr = new JPostIncrementOp(line, primaryExpr); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return primaryExpr; }
}

/**
 * Parses a selector and returns an AST for it.
 *
 * <pre>
 *   selector ::= DOT qualifiedIdentifier [ arguments ]
 *              | LBRACK expression RBRACK
 * </pre>
 *
 * @param target the target expression for this selector.
 * @return an AST for a selector.
 */
private JExpression selector(JExpression target):
{
    int line = 0;
    ArrayList<JExpression> args = null;
    TypeName id = null;
    JExpression expr = null;
}
{
    try {
        <DOT>
        { line = token.beginLine; }
        id = qualifiedIdentifier()
        { expr = new JFieldSelection(line, ambiguousPart(id), target, id.simpleName()); }
        [
            args = arguments()
            { expr = new JMessageExpression(line, target, ambiguousPart(id), id.simpleName(),
                                            args); }
        ] |
        <LBRACK>
        { line = token.beginLine; }
        { expr = new JArrayExpression(line, target, expression()); }
        <RBRACK>
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses a primary expression and returns an AST for it.
 *
 * <pre>
 *   primary ::= parExpression
 *             | NEW creator
 *             | THIS [ arguments ]
 *             | SUPER ( arguments | DOT IDENTIFIER [ arguments ] )
 *             | qualifiedIdentifier [ arguments ]
 *             | literal
 * </pre>
 *
 * @return an AST for a primary expression.
 */
private JExpression primary():
{
    int line = 0;
    String name = "";
    JExpression expr = null;
    JExpression newTarget = null;
    ArrayList<JExpression> args = null;
    TypeName id = null;
}
{
    try {
        expr = parExpression() |
        <NEW>
        expr = creator() |
        <THIS>
        {
            line = token.beginLine;
            expr = new JThis(line);
        }
        [
            args = arguments()
            { expr = new JThisConstruction(line, args); }
        ] |
        <SUPER>
        { line = token.beginLine; }
        (
            args = arguments()
            { expr = new JSuperConstruction(line, args); } |
            <DOT> <IDENTIFIER>
            {
                name = token.image;
                newTarget = new JSuper(line);
                expr = new JFieldSelection(line, newTarget, name);
            }
            [
                args = arguments()
                { expr = new JMessageExpression(line, newTarget, null, name, args); }
            ]
        ) |
        // Language is ambiguous here. JavaCC is unable to choose between qualifiedIdentifier and
        // selector. Semantic analysis will sort it out.
        id = qualifiedIdentifier()
        {
            line = id.line();
            if (ambiguousPart(id) == null) {
                expr = new JVariable(line, id.simpleName());
            } else {
                expr = new JFieldSelection(line, ambiguousPart(id), null, id.simpleName());
            }
        }
        [
            args = arguments()
            { expr = new JMessageExpression(line, null, ambiguousPart(id), id.simpleName(), args); }
        ] |
        expr = literal()
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses a creator and returns an AST for it.
 *
 * <pre>
 *   creator ::= ( basicType | qualifiedIdentifier )
 *                   ( arguments
 *                   | LBRACK RBRACK { LBRACK RBRACK } [ arrayInitializer ]
 *                   | newArrayDeclarator
 *                   )
 * </pre>
 *
 * @return an AST for a creator.
 */
private JExpression creator():
{
    int line = 0;
    Type type = null;
    ArrayList<JExpression> args = null;
    ArrayList<JExpression> dims = null;
    JArrayInitializer init =  null;
    JExpression expr = null;
    Type expected = null;
}
{
    try {
        (
            type = basicType() |
            type = qualifiedIdentifier()
        )
        {
            line = token.beginLine;
            expected = type;
        }
        (
            args = arguments()
            { expr = new JNewOp(line, type, args); } |
            LOOKAHEAD(<LBRACK> <RBRACK>)
            <LBRACK> <RBRACK>
            { expected = new ArrayTypeName(expected); }
            (
                LOOKAHEAD(<LBRACK> <RBRACK>)
                <LBRACK> <RBRACK>
                { expected = new ArrayTypeName(expected); }
            )*
            [
               expr = arrayInitializer(expected)
            ] |
            expr = newArrayDeclarator(type)
        )
    } catch (ParseException e) {
        expr = new JWildExpression(token.beginLine);
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}

/**
 * Parses a new array declarator and returns an AST for it.
 *
 * <pre>
 *   newArrayDeclarator ::= LBRACK expression RBRACK { LBRACK expression RBRACK } { LBRACK RBRACK }
 * </pre>
 *
 * @param line line in which the declarator occurred.
 * @param type type of the array.
 * @return an AST for a new array declarator.
 */
private JNewArrayOp newArrayDeclarator(Type type):
{
    int line = 0;
    ArrayList<JExpression> dimensions = new ArrayList<JExpression>();
    JExpression expr = null;
}
{
    try {
        <LBRACK>
        { line = token.beginLine; }
        expr = expression() 
        {
            dimensions.add(expr);
            type = new ArrayTypeName(type);
        }
        <RBRACK>
        (
            LOOKAHEAD(<LBRACK> expression() <RBRACK>)
            <LBRACK>
            expr = expression()
            {
                dimensions.add(expr);
                type = new ArrayTypeName(type);
            }
            <RBRACK>
        )*
        (
            LOOKAHEAD(<LBRACK> <RBRACK>)
            <LBRACK> <RBRACK>
            { type = new ArrayTypeName(type); }
        )*
    } catch (ParseException e) {
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return new JNewArrayOp(line, type, dimensions); }
}

/**
 * Parses a literal and returns an AST for it.
 *
 * <pre>
 *   literal ::= CHAR_LITERAL | FALSE | INT_LITERAL | LONG_LITERAL | DOUBLE_LITERAL | NULL | STRING_LITERAL | TRUE
 * </pre>
 *
 * @return an AST for a literal.
 */
private JExpression literal():
{
    JExpression expr = null;
}
{
    try {
        <CHAR_LITERAL>
        { expr = new JLiteralChar(token.beginLine, token.image); } |
        // I added the DOUBLE_LITERAL for the parser
        <DOUBLE_LITERAL>
        { expr = new JLiteralDouble(token.beginLine, token.image); } |
        <FALSE>
        { expr = new JLiteralBoolean(token.beginLine, token.image); } |
        <INT_LITERAL>
        { expr = new JLiteralInt(token.beginLine, token.image); } |
        // I added the LONG_LITERAL for the parser
        <LONG_LITERAL>
        { expr = new JLiteralLong(token.beginLine, token.image); } |
        <NULL>
        { expr = new JLiteralNull(token.beginLine); } |
        <STRING_LITERAL>
        { expr = new JLiteralString(token.beginLine, token.image); } |
        <TRUE>
        { expr = new JLiteralBoolean(token.beginLine, token.image); }
    } catch (ParseException e) {
        expr = new JWildExpression(token.beginLine);
        recoverFromError(new int[] { SEMI, EOF }, e);
    }
    { return expr; }
}
